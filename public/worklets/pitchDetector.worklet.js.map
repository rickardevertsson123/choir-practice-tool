{
  "version": 3,
  "sources": ["../../node_modules/fft.js/lib/fft.js", "../../node_modules/pitchy/index.js", "../../src/audio/pitchDetection.ts", "../../src/audio/worklets/pitchDetector.worklet.ts"],
  "sourcesContent": ["'use strict';\n\nfunction FFT(size) {\n  this.size = size | 0;\n  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n    throw new Error('FFT size must be a power of two and bigger than 1');\n\n  this._csize = size << 1;\n\n  // NOTE: Use of `var` is intentional for old V8 versions\n  var table = new Array(this.size * 2);\n  for (var i = 0; i < table.length; i += 2) {\n    const angle = Math.PI * i / this.size;\n    table[i] = Math.cos(angle);\n    table[i + 1] = -Math.sin(angle);\n  }\n  this.table = table;\n\n  // Find size's power of two\n  var power = 0;\n  for (var t = 1; this.size > t; t <<= 1)\n    power++;\n\n  // Calculate initial step's width:\n  //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n  //   * Otherwise it is the same as `power` to give len=4\n  this._width = power % 2 === 0 ? power - 1 : power;\n\n  // Pre-compute bit-reversal patterns\n  this._bitrev = new Array(1 << this._width);\n  for (var j = 0; j < this._bitrev.length; j++) {\n    this._bitrev[j] = 0;\n    for (var shift = 0; shift < this._width; shift += 2) {\n      var revShift = this._width - shift - 2;\n      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n    }\n  }\n\n  this._out = null;\n  this._data = null;\n  this._inv = 0;\n}\nmodule.exports = FFT;\n\nFFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\n  var res = storage || new Array(complex.length >>> 1);\n  for (var i = 0; i < complex.length; i += 2)\n    res[i >>> 1] = complex[i];\n  return res;\n};\n\nFFT.prototype.createComplexArray = function createComplexArray() {\n  const res = new Array(this._csize);\n  for (var i = 0; i < res.length; i++)\n    res[i] = 0;\n  return res;\n};\n\nFFT.prototype.toComplexArray = function toComplexArray(input, storage) {\n  var res = storage || this.createComplexArray();\n  for (var i = 0; i < res.length; i += 2) {\n    res[i] = input[i >>> 1];\n    res[i + 1] = 0;\n  }\n  return res;\n};\n\nFFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\n  var size = this._csize;\n  var half = size >>> 1;\n  for (var i = 2; i < half; i += 2) {\n    spectrum[size - i] = spectrum[i];\n    spectrum[size - i + 1] = -spectrum[i + 1];\n  }\n};\n\nFFT.prototype.transform = function transform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._transform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.realTransform = function realTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._realTransform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.inverseTransform = function inverseTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 1;\n  this._transform4();\n  for (var i = 0; i < out.length; i++)\n    out[i] /= this.size;\n  this._out = null;\n  this._data = null;\n};\n\n// radix-4 implementation\n//\n// NOTE: Uses of `var` are intentional for older V8 version that do not\n// support both `let compound assignments` and `const phi`\nFFT.prototype._transform4 = function _transform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform2(outOff, off, step);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform4(outOff, off, step);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var quarterLen = len >>> 2;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      // Full case\n      var limit = outOff + quarterLen;\n      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {\n        const A = i;\n        const B = A + quarterLen;\n        const C = B + quarterLen;\n        const D = C + quarterLen;\n\n        // Original values\n        const Ar = out[A];\n        const Ai = out[A + 1];\n        const Br = out[B];\n        const Bi = out[B + 1];\n        const Cr = out[C];\n        const Ci = out[C + 1];\n        const Dr = out[D];\n        const Di = out[D + 1];\n\n        // Middle values\n        const MAr = Ar;\n        const MAi = Ai;\n\n        const tableBr = table[k];\n        const tableBi = inv * table[k + 1];\n        const MBr = Br * tableBr - Bi * tableBi;\n        const MBi = Br * tableBi + Bi * tableBr;\n\n        const tableCr = table[2 * k];\n        const tableCi = inv * table[2 * k + 1];\n        const MCr = Cr * tableCr - Ci * tableCi;\n        const MCi = Cr * tableCi + Ci * tableCr;\n\n        const tableDr = table[3 * k];\n        const tableDi = inv * table[3 * k + 1];\n        const MDr = Dr * tableDr - Di * tableDi;\n        const MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        const T0r = MAr + MCr;\n        const T0i = MAi + MCi;\n        const T1r = MAr - MCr;\n        const T1i = MAi - MCi;\n        const T2r = MBr + MDr;\n        const T2i = MBi + MDi;\n        const T3r = inv * (MBr - MDr);\n        const T3i = inv * (MBi - MDi);\n\n        // Final values\n        const FAr = T0r + T2r;\n        const FAi = T0i + T2i;\n\n        const FCr = T0r - T2r;\n        const FCi = T0i - T2i;\n\n        const FBr = T1r + T3i;\n        const FBi = T1i - T3r;\n\n        const FDr = T1r - T3i;\n        const FDi = T1i + T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n        out[C] = FCr;\n        out[C + 1] = FCi;\n        out[D] = FDr;\n        out[D + 1] = FDi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const evenI = data[off + 1];\n  const oddR = data[off + step];\n  const oddI = data[off + step + 1];\n\n  const leftR = evenR + oddR;\n  const leftI = evenI + oddI;\n  const rightR = evenR - oddR;\n  const rightI = evenI - oddI;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = leftI;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = rightI;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Ai = data[off + 1];\n  const Br = data[off + step];\n  const Bi = data[off + step + 1];\n  const Cr = data[off + step2];\n  const Ci = data[off + step2 + 1];\n  const Dr = data[off + step3];\n  const Di = data[off + step3 + 1];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T0i = Ai + Ci;\n  const T1r = Ar - Cr;\n  const T1i = Ai - Ci;\n  const T2r = Br + Dr;\n  const T2i = Bi + Di;\n  const T3r = inv * (Br - Dr);\n  const T3i = inv * (Bi - Di);\n\n  // Final values\n  const FAr = T0r + T2r;\n  const FAi = T0i + T2i;\n\n  const FBr = T1r + T3i;\n  const FBi = T1i - T3r;\n\n  const FCr = T0r - T2r;\n  const FCi = T0i - T2i;\n\n  const FDr = T1r - T3i;\n  const FDi = T1i + T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = FAi;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = FCi;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n\n// Real input radix-4 implementation\nFFT.prototype._realTransform4 = function _realTransform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var halfLen = len >>> 1;\n    var quarterLen = halfLen >>> 1;\n    var hquarterLen = quarterLen >>> 1;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n        var A = outOff + i;\n        var B = A + quarterLen;\n        var C = B + quarterLen;\n        var D = C + quarterLen;\n\n        // Original values\n        var Ar = out[A];\n        var Ai = out[A + 1];\n        var Br = out[B];\n        var Bi = out[B + 1];\n        var Cr = out[C];\n        var Ci = out[C + 1];\n        var Dr = out[D];\n        var Di = out[D + 1];\n\n        // Middle values\n        var MAr = Ar;\n        var MAi = Ai;\n\n        var tableBr = table[k];\n        var tableBi = inv * table[k + 1];\n        var MBr = Br * tableBr - Bi * tableBi;\n        var MBi = Br * tableBi + Bi * tableBr;\n\n        var tableCr = table[2 * k];\n        var tableCi = inv * table[2 * k + 1];\n        var MCr = Cr * tableCr - Ci * tableCi;\n        var MCi = Cr * tableCi + Ci * tableCr;\n\n        var tableDr = table[3 * k];\n        var tableDi = inv * table[3 * k + 1];\n        var MDr = Dr * tableDr - Di * tableDi;\n        var MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        var T0r = MAr + MCr;\n        var T0i = MAi + MCi;\n        var T1r = MAr - MCr;\n        var T1i = MAi - MCi;\n        var T2r = MBr + MDr;\n        var T2i = MBi + MDi;\n        var T3r = inv * (MBr - MDr);\n        var T3i = inv * (MBi - MDi);\n\n        // Final values\n        var FAr = T0r + T2r;\n        var FAi = T0i + T2i;\n\n        var FBr = T1r + T3i;\n        var FBi = T1i - T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n\n        // Output final middle point\n        if (i === 0) {\n          var FCr = T0r - T2r;\n          var FCi = T0i - T2i;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          continue;\n        }\n\n        // Do not overwrite ourselves\n        if (i === hquarterLen)\n          continue;\n\n        // In the flipped case:\n        // MAi = -MAi\n        // MBr=-MBi, MBi=-MBr\n        // MCr=-MCr\n        // MDr=MDi, MDi=MDr\n        var ST0r = T1r;\n        var ST0i = -T1i;\n        var ST1r = T0r;\n        var ST1i = -T0i;\n        var ST2r = -inv * T3i;\n        var ST2i = -inv * T3r;\n        var ST3r = -inv * T2i;\n        var ST3i = -inv * T2r;\n\n        var SFAr = ST0r + ST2r;\n        var SFAi = ST0i + ST2i;\n\n        var SFBr = ST1r + ST3i;\n        var SFBi = ST1i - ST3r;\n\n        var SA = outOff + quarterLen - i;\n        var SB = outOff + halfLen - i;\n\n        out[SA] = SFAr;\n        out[SA + 1] = SFAi;\n        out[SB] = SFBr;\n        out[SB + 1] = SFBi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const oddR = data[off + step];\n\n  const leftR = evenR + oddR;\n  const rightR = evenR - oddR;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = 0;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Br = data[off + step];\n  const Cr = data[off + step2];\n  const Dr = data[off + step3];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T1r = Ar - Cr;\n  const T2r = Br + Dr;\n  const T3r = inv * (Br - Dr);\n\n  // Final values\n  const FAr = T0r + T2r;\n\n  const FBr = T1r;\n  const FBi = -T3r;\n\n  const FCr = T0r - T2r;\n\n  const FDr = T1r;\n  const FDi = T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = 0;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n", "import FFT from \"fft.js\";\n\n/**\n * @typedef {Float32Array | Float64Array | number[]} Buffer One of the supported\n * buffer types. Other numeric array types may not work correctly.\n */\n\n/**\n * A class that can perform autocorrelation on input arrays of a given size.\n *\n * The class holds internal buffers so that no additional allocations are\n * necessary while performing the operation.\n *\n * @template {Buffer} T the buffer type to use. While inputs to the\n * autocorrelation process can be any array-like type, the output buffer\n * (whether provided explicitly or using a fresh buffer) is always of this type.\n */\nexport class Autocorrelator {\n  /** @private @readonly @type {number} */\n  _inputLength;\n  /** @private @type {FFT} */\n  _fft;\n  /** @private @type {(size: number) => T} */\n  _bufferSupplier;\n  /** @private @type {T} */\n  _paddedInputBuffer;\n  /** @private @type {T} */\n  _transformBuffer;\n  /** @private @type {T} */\n  _inverseBuffer;\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using\n   * {@link Float32Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<Float32Array>}\n   */\n  static forFloat32Array(inputLength) {\n    return new Autocorrelator(\n      inputLength,\n      (length) => new Float32Array(length),\n    );\n  }\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using\n   * {@link Float64Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<Float64Array>}\n   */\n  static forFloat64Array(inputLength) {\n    return new Autocorrelator(\n      inputLength,\n      (length) => new Float64Array(length),\n    );\n  }\n\n  /**\n   * A helper method to create an {@link Autocorrelator} using `number[]`\n   * buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {Autocorrelator<number[]>}\n   */\n  static forNumberArray(inputLength) {\n    return new Autocorrelator(inputLength, (length) => Array(length));\n  }\n\n  /**\n   * Constructs a new {@link Autocorrelator} able to handle input arrays of the\n   * given length.\n   *\n   * @param inputLength {number} the input array length to support. This\n   * `Autocorrelator` will only support operation on arrays of this length.\n   * @param bufferSupplier {(length: number) => T} the function to use for\n   * creating buffers, accepting the length of the buffer to create and\n   * returning a new buffer of that length. The values of the returned buffer\n   * need not be initialized in any particular way.\n   */\n  constructor(inputLength, bufferSupplier) {\n    if (inputLength < 1) {\n      throw new Error(`Input length must be at least one`);\n    }\n    this._inputLength = inputLength;\n    // We need to double the input length to get correct results, and the FFT\n    // algorithm we use requires a length that's a power of 2\n    this._fft = new FFT(ceilPow2(2 * inputLength));\n    this._bufferSupplier = bufferSupplier;\n    this._paddedInputBuffer = this._bufferSupplier(this._fft.size);\n    this._transformBuffer = this._bufferSupplier(2 * this._fft.size);\n    this._inverseBuffer = this._bufferSupplier(2 * this._fft.size);\n  }\n\n  /**\n   * Returns the supported input length.\n   *\n   * @returns {number} the supported input length\n   */\n  get inputLength() {\n    return this._inputLength;\n  }\n\n  /**\n   * Autocorrelates the given input data.\n   *\n   * @param input {ArrayLike<number>} the input data to autocorrelate\n   * @param output {T} the output buffer into which to write the autocorrelated\n   * data. If not provided, a new buffer will be created.\n   * @returns {T} `output`\n   */\n  autocorrelate(input, output = this._bufferSupplier(input.length)) {\n    if (input.length !== this._inputLength) {\n      throw new Error(\n        `Input must have length ${this._inputLength} but had length ${input.length}`,\n      );\n    }\n    // Step 0: pad the input array with zeros\n    for (let i = 0; i < input.length; i++) {\n      this._paddedInputBuffer[i] = input[i];\n    }\n    for (let i = input.length; i < this._paddedInputBuffer.length; i++) {\n      this._paddedInputBuffer[i] = 0;\n    }\n\n    // Step 1: get the DFT of the input array\n    this._fft.realTransform(this._transformBuffer, this._paddedInputBuffer);\n    // We need to fill in the right half of the array too\n    this._fft.completeSpectrum(this._transformBuffer);\n    // Step 2: multiply each entry by its conjugate\n    const tb = this._transformBuffer;\n    for (let i = 0; i < tb.length; i += 2) {\n      tb[i] = tb[i] * tb[i] + tb[i + 1] * tb[i + 1];\n      tb[i + 1] = 0;\n    }\n    // Step 3: perform the inverse transform\n    this._fft.inverseTransform(this._inverseBuffer, this._transformBuffer);\n\n    // This last result (the inverse transform) contains the autocorrelation\n    // data, which is completely real\n    for (let i = 0; i < input.length; i++) {\n      output[i] = this._inverseBuffer[2 * i];\n    }\n    return output;\n  }\n}\n\n/**\n * Returns an array of all the key maximum positions in the given input array.\n *\n * In McLeod's paper, a key maximum is the highest maximum between a positively\n * sloped zero crossing and a negatively sloped one.\n *\n * TODO: it may be more efficient not to construct a new output array each time,\n * but that would also make the code more complicated (more so than the changes\n * that were needed to remove the other allocations).\n *\n * @param input {ArrayLike<number>}\n * @returns {number[]}\n */\nfunction getKeyMaximumIndices(input) {\n  // The indices of the key maxima\n  /** @type {number[]} */ const keyIndices = [];\n  // Whether the last zero crossing found was positively sloped; equivalently,\n  // whether we're looking for a key maximum\n  let lookingForMaximum = false;\n  // The largest local maximum found so far\n  let max = -Infinity;\n  // The index of the largest local maximum so far\n  let maxIndex = -1;\n\n  for (let i = 1; i < input.length - 1; i++) {\n    if (input[i - 1] <= 0 && input[i] > 0) {\n      // Positively sloped zero crossing\n      lookingForMaximum = true;\n      maxIndex = i;\n      max = input[i];\n    } else if (input[i - 1] > 0 && input[i] <= 0) {\n      // Negatively sloped zero crossing\n      lookingForMaximum = false;\n      if (maxIndex !== -1) {\n        keyIndices.push(maxIndex);\n      }\n    } else if (lookingForMaximum && input[i] > max) {\n      max = input[i];\n      maxIndex = i;\n    }\n  }\n\n  return keyIndices;\n}\n\n/**\n * Refines the chosen key maximum index chosen from the given data by\n * interpolating a parabola using the key maximum index and its two neighbors\n * and finding the position of that parabola's maximum value.\n *\n * This is described in section 5 of the MPM paper as a way to refine the\n * position of the maximum.\n *\n * @param index {number} the chosen key maximum index. This must be between `1`\n * and `data.length - 2`, inclusive, since it and its two neighbors need to be\n * valid indexes of `data`.\n * @param data {ArrayLike<number>} the input array from which `index` was chosen\n * @returns {[number, number]} a pair consisting of the refined key maximum index and the\n * interpolated value of `data` at that index (the latter of which is used as a\n * measure of clarity)\n */\nfunction refineResultIndex(index, data) {\n  const [x0, x1, x2] = [index - 1, index, index + 1];\n  const [y0, y1, y2] = [data[x0], data[x1], data[x2]];\n\n  // The parabola going through the three data points can be written as\n  // y = y0(x - x1)(x - x2)/(x0 - x1)(x0 - x2)\n  //   + y1(x - x0)(x - x2)/(x1 - x0)(x1 - x2)\n  //   + y2(x - x0)(x - x1)/(x2 - x0)(x2 - x1)\n  // Given the definitions of x0, x1, and x2, we can simplify the denominators:\n  // y = y0(x - x1)(x - x2)/2\n  //   - y1(x - x0)(x - x2)\n  //   + y2(x - x0)(x - x1)/2\n  // We can expand this out and get the coefficients in standard form:\n  // a = y0/2 - y1 + y2/2\n  // b = -(y0/2)(x1 + x2) + y1(x0 + x2) - (y2/2)(x0 + x1)\n  // c = y0x1x2/2 - y1x0x2 + y2x0x1/2\n  // The index of the maximum is -b / 2a (by solving for x where the derivative\n  // is 0).\n\n  const a = y0 / 2 - y1 + y2 / 2;\n  const b = -(y0 / 2) * (x1 + x2) + y1 * (x0 + x2) - (y2 / 2) * (x0 + x1);\n  const c = (y0 * x1 * x2) / 2 - y1 * x0 * x2 + (y2 * x0 * x1) / 2;\n\n  const xMax = -b / (2 * a);\n  const yMax = a * xMax * xMax + b * xMax + c;\n  return [xMax, yMax];\n}\n\n/**\n * A class that can detect the pitch of a note from a time-domain input array.\n *\n * This class uses the McLeod pitch method (MPM) to detect pitches. MPM is\n * described in the paper 'A Smarter Way to Find Pitch' by Philip McLeod and\n * Geoff Wyvill\n * (http://miracle.otago.ac.nz/tartini/papers/A_Smarter_Way_to_Find_Pitch.pdf).\n *\n * The class holds internal buffers so that a minimal number of additional\n * allocations are necessary while performing the operation.\n *\n * @template {Buffer} T the buffer type to use internally. Inputs to the\n * pitch-detection process can be any numeric array type.\n */\nexport class PitchDetector {\n  /** @private @type {Autocorrelator<T>} */\n  _autocorrelator;\n  /** @private @type {T} */\n  _nsdfBuffer;\n  /** @private @type {number} */\n  _clarityThreshold = 0.9;\n  /** @private @type {number} */\n  _minVolumeAbsolute = 0.0;\n  /** @private @type {number} */\n  _maxInputAmplitude = 1.0;\n\n  /**\n   * A helper method to create an {@link PitchDetector} using {@link Float32Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<Float32Array>}\n   */\n  static forFloat32Array(inputLength) {\n    return new PitchDetector(inputLength, (length) => new Float32Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link PitchDetector} using {@link Float64Array} buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<Float64Array>}\n   */\n  static forFloat64Array(inputLength) {\n    return new PitchDetector(inputLength, (length) => new Float64Array(length));\n  }\n\n  /**\n   * A helper method to create an {@link PitchDetector} using `number[]` buffers.\n   *\n   * @param inputLength {number} the input array length to support\n   * @returns {PitchDetector<number[]>}\n   */\n  static forNumberArray(inputLength) {\n    return new PitchDetector(inputLength, (length) => Array(length));\n  }\n\n  /**\n   * Constructs a new {@link PitchDetector} able to handle input arrays of the\n   * given length.\n   *\n   * @param inputLength {number} the input array length to support. This\n   * `PitchDetector` will only support operation on arrays of this length.\n   * @param bufferSupplier {(inputLength: number) => T} the function to use for\n   * creating buffers, accepting the length of the buffer to create and\n   * returning a new buffer of that length. The values of the returned buffer\n   * need not be initialized in any particular way.\n   */\n  constructor(inputLength, bufferSupplier) {\n    this._autocorrelator = new Autocorrelator(inputLength, bufferSupplier);\n    this._nsdfBuffer = bufferSupplier(inputLength);\n  }\n\n  /**\n   * Returns the supported input length.\n   *\n   * @returns {number} the supported input length\n   */\n  get inputLength() {\n    return this._autocorrelator.inputLength;\n  }\n\n  /**\n   * Sets the clarity threshold used when identifying the correct pitch (the constant\n   * `k` from the MPM paper). The value must be between 0 (exclusive) and 1\n   * (inclusive), with the most suitable range being between 0.8 and 1.\n   *\n   * @param threshold {number} the clarity threshold\n   */\n  set clarityThreshold(threshold) {\n    if (!Number.isFinite(threshold) || threshold <= 0 || threshold > 1) {\n      throw new Error(\"clarityThreshold must be a number in the range (0, 1]\");\n    }\n    this._clarityThreshold = threshold;\n  }\n\n  /**\n   * Sets the minimum detectable volume, as an absolute number between 0 and\n   * `maxInputAmplitude`, inclusive, to consider in a sample when detecting the\n   * pitch. If a sample fails to meet this minimum volume, `findPitch` will\n   * return a clarity of 0.\n   *\n   * Volume is calculated as the RMS (root mean square) of the input samples.\n   *\n   * @param volume {number} the minimum volume as an absolute amplitude value\n   */\n  set minVolumeAbsolute(volume) {\n    if (\n      !Number.isFinite(volume) ||\n      volume < 0 ||\n      volume > this._maxInputAmplitude\n    ) {\n      throw new Error(\n        `minVolumeAbsolute must be a number in the range [0, ${this._maxInputAmplitude}]`,\n      );\n    }\n    this._minVolumeAbsolute = volume;\n  }\n\n  /**\n   * Sets the minimum volume using a decibel measurement. Must be less than or\n   * equal to 0: 0 indicates the loudest possible sound (see\n   * `maxInputAmplitude`), -10 is a sound with a tenth of the volume of the\n   * loudest possible sound, etc.\n   *\n   * Volume is calculated as the RMS (root mean square) of the input samples.\n   *\n   * @param db {number} the minimum volume in decibels, with 0 being the loudest\n   * sound\n   */\n  set minVolumeDecibels(db) {\n    if (!Number.isFinite(db) || db > 0) {\n      throw new Error(\"minVolumeDecibels must be a number <= 0\");\n    }\n    this._minVolumeAbsolute = this._maxInputAmplitude * 10 ** (db / 10);\n  }\n\n  /**\n   * Sets the maximum amplitude of an input reading. Must be greater than 0.\n   *\n   * @param amplitude {number} the maximum amplitude (absolute value) of an input reading\n   */\n  set maxInputAmplitude(amplitude) {\n    if (!Number.isFinite(amplitude) || amplitude <= 0) {\n      throw new Error(\"maxInputAmplitude must be a number > 0\");\n    }\n    this._maxInputAmplitude = amplitude;\n  }\n\n  /**\n   * Returns the pitch detected using McLeod Pitch Method (MPM) along with a\n   * measure of its clarity.\n   *\n   * The clarity is a value between 0 and 1 (potentially inclusive) that\n   * represents how \"clear\" the pitch was. A clarity value of 1 indicates that\n   * the pitch was very distinct, while lower clarity values indicate less\n   * definite pitches.\n   *\n   * @param input {ArrayLike<number>} the time-domain input data\n   * @param sampleRate {number} the sample rate at which the input data was\n   * collected\n   * @returns {[number, number]} the detected pitch, in Hz, followed by the\n   * clarity. If a pitch cannot be determined from the input, such as if the\n   * volume is too low (see `minVolumeAbsolute` and `minVolumeDecibels`), this\n   * will be `[0, 0]`.\n   */\n  findPitch(input, sampleRate) {\n    // If the highest key maximum is less than the minimum volume, we don't need\n    // to bother detecting the pitch, as the sample is too quiet.\n    if (this._belowMinimumVolume(input)) return [0, 0];\n    this._nsdf(input);\n    const keyMaximumIndices = getKeyMaximumIndices(this._nsdfBuffer);\n    if (keyMaximumIndices.length === 0) {\n      // No key maxima means that we either don't have enough data to analyze or\n      // that the data was flawed (such as an input array of zeroes)\n      return [0, 0];\n    }\n    // The highest key maximum\n    const nMax = Math.max(...keyMaximumIndices.map((i) => this._nsdfBuffer[i]));\n    // Following the paper, we return the pitch corresponding to the first key\n    // maximum higher than K * nMax. This is guaranteed not to be undefined, since\n    // we know of at least one key maximum satisfying this condition (whichever\n    // key maximum gave us nMax).\n    const resultIndex = keyMaximumIndices.find(\n      (i) => this._nsdfBuffer[i] >= this._clarityThreshold * nMax,\n    );\n    const [refinedResultIndex, clarity] = refineResultIndex(\n      // @ts-expect-error resultIndex is guaranteed to be defined\n      resultIndex,\n      this._nsdfBuffer,\n    );\n\n    // Due to floating point errors, the clarity may occasionally come out to be\n    // slightly over 1.0. We can avoid incorrect results by clamping the value.\n    return [sampleRate / refinedResultIndex, Math.min(clarity, 1.0)];\n  }\n\n  /**\n   * Returns whether the input audio data is below the minimum volume allowed by\n   * the pitch detector.\n   *\n   * @private\n   * @param input {ArrayLike<number>}\n   * @returns {boolean}\n   */\n  _belowMinimumVolume(input) {\n    if (this._minVolumeAbsolute === 0) return false;\n    let squareSum = 0;\n    for (let i = 0; i < input.length; i++) {\n      squareSum += input[i] ** 2;\n    }\n    return Math.sqrt(squareSum / input.length) < this._minVolumeAbsolute;\n  }\n\n  /**\n   * Computes the NSDF of the input and stores it in the internal buffer. This\n   * is equation (9) in the McLeod pitch method paper.\n   *\n   * @private\n   * @param input {ArrayLike<number>}\n   */\n  _nsdf(input) {\n    // The function r'(tau) is the autocorrelation\n    this._autocorrelator.autocorrelate(input, this._nsdfBuffer);\n    // The function m'(tau) (defined in equation (6)) can be computed starting\n    // with m'(0), which is equal to 2r'(0), and then iteratively modified to\n    // get m'(1), m'(2), etc. For example, to get m'(1), we take m'(0) and\n    // subtract x_0^2 and x_{W-1}^2. Then, to get m'(2), we take m'(1) and\n    // subtract x_1^2 and x_{W-2}^2, and further values are similar (see the\n    // note at the end of section 6 in the MPM paper).\n    //\n    // The resulting array values are 2 * r'(tau) / m'(tau). We use m below as\n    // the incremental value of m'.\n    let m = 2 * this._nsdfBuffer[0];\n    /** @type {number} */ let i;\n    // As pointed out by issuefiler on GitHub, we can take advantage of the fact\n    // that m will never increase to avoid division by zero by ending this loop\n    // once m === 0. The rest of the array values after m becomes 0 will just be\n    // set to 0 themselves. We actually check for m > 0 rather than m === 0\n    // because there may be small floating-point errors that cause m to become\n    // negative rather than exactly 0.\n    for (i = 0; i < this._nsdfBuffer.length && m > 0; i++) {\n      this._nsdfBuffer[i] = (2 * this._nsdfBuffer[i]) / m;\n      m -= input[i] ** 2 + input[input.length - i - 1] ** 2;\n    }\n    // If there are any array values remaining, it means m === 0 for those\n    // values of tau, so we can just set them to 0\n    for (; i < this._nsdfBuffer.length; i++) {\n      this._nsdfBuffer[i] = 0;\n    }\n  }\n}\n\n/**\n * Rounds up the input to the next power of 2.\n *\n * @param {number} v\n * @returns {number} the next power of 2 at least as large as `v`\n */\nfunction ceilPow2(v) {\n  // https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n  v--;\n  v |= v >> 1;\n  v |= v >> 2;\n  v |= v >> 4;\n  v |= v >> 8;\n  v |= v >> 16;\n  v++;\n  return v;\n}\n", "// Pitch detection using normalized autocorrelation (NACF) + parabolic interpolation.\n// Target-aware only for NACF search range (\u00B13 semitones), never \"snaps\" pitch to target.\n// Includes an internal spike gate to suppress 1-frame pitch jumps (e.g. at note boundaries).\n//\n// Performance notes:\n// - detectPitch is allocation-free per call by reusing internal buffers\n//   (Hann window coefficients, windowed buffer, prefix energy buffer).\n\n/*\n * Copyright (c) 2025 Rickard Evertsson\n */\n\nimport { PitchDetector } from 'pitchy';\n\nexport interface PitchResult {\n  frequency: number | null; // null if no stable pitch detected\n  clarity: number;          // 0-1, confidence of detection\n  debugReason?: string | null; // optional UI/debug info\n}\n\nexport interface TargetHint {\n  targetMidi: number; // Expected MIDI note\n}\n\nexport interface NoteInfo {\n  noteName: string;   // e.g. \"A4\"\n  midi: number;       // e.g. 69 (rounded)\n  exactMidi: number;  // e.g. 69.15 (fractional)\n  centsOff: number;   // e.g. -15 (below nearest tone)\n}\n\nconst NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n\n// ---------- Tunables ----------\nconst DEFAULT_MIN_FREQ = 80;      // Hz\nconst DEFAULT_MAX_FREQ = 1000;    // Hz\nconst TARGET_SEMITONE_SPAN = 3;   // \u00B13 semitones search window when targetHint exists (NACF path only)\n\n// Energy / clarity thresholds\nconst RMS_THRESHOLD = 0.005;      // you said you set this for testing; keep it here\nconst MIN_CLARITY = 0.35;         // lower than 0.4 to reduce \"no pitch\" cases, still strict-ish\n\n// Spike gate: suppress short-lived pitch jumps (helps note transitions)\nconst SPIKE_GATE_CENTS = 80;      // jump must exceed this to be considered a spike\nconst SPIKE_GATE_CONFIRM_FRAMES = 2; // require 2 consecutive frames to accept large jump\n\n// -----------------------------\n\n// Internal singleton state (keeps behavior stable without changing ScorePlayerPage)\ntype DetectorState = {\n  lastStableMidi: number | null;\n  pendingJumpMidi: number | null;\n  pendingJumpCount: number;\n};\n\nconst state: DetectorState = {\n  lastStableMidi: null,\n  pendingJumpMidi: null,\n  pendingJumpCount: 0,\n};\n\ntype Workspace = {\n  n: number;\n  hann: Float32Array;\n  windowed: Float32Array;\n  prefixEnergy: Float64Array; // length n+1\n};\n\n// Module-level reusable workspace. This avoids per-call allocations without\n// forcing callers to manage buffers.\nconst ws: Workspace = {\n  n: 0,\n  hann: new Float32Array(0),\n  windowed: new Float32Array(0),\n  prefixEnergy: new Float64Array(0),\n};\n\n// Pitchy workspace: reuse one detector instance per buffer size.\nlet pitchyDetectorN = 0;\nlet pitchyDetector: PitchDetector<Float32Array> | null = null;\nfunction getPitchyDetector(n: number): PitchDetector<Float32Array> {\n  if (!pitchyDetector || pitchyDetectorN !== n) {\n    pitchyDetector = PitchDetector.forFloat32Array(n);\n    pitchyDetectorN = n;\n  }\n  return pitchyDetector;\n}\n\nexport type DetectorKind = 'nacf' | 'pitchy';\n\n// Exported for A/B testing / future re-enable (avoids TS noUnusedLocals in builds).\nexport function getDetectorKind(): DetectorKind {\n  // Vite exposes env vars on import.meta.env (only keys with VITE_ prefix).\n  // We read defensively so this module remains safe in AudioWorklet bundles too.\n  const raw = String(((import.meta as any)?.env?.VITE_PITCH_DETECTOR ?? 'pitchy')).toLowerCase();\n  return raw === 'nacf' ? 'nacf' : 'pitchy';\n}\n\nfunction ensureWorkspace(n: number): Workspace {\n  if (ws.n === n) return ws;\n\n  ws.n = n;\n  ws.hann = new Float32Array(n);\n  ws.windowed = new Float32Array(n);\n  ws.prefixEnergy = new Float64Array(n + 1);\n\n  if (n > 1) {\n    const k = (2 * Math.PI) / (n - 1);\n    for (let i = 0; i < n; i++) {\n      // Hann window\n      ws.hann[i] = 0.5 * (1 - Math.cos(k * i));\n    }\n  } else if (n === 1) {\n    ws.hann[0] = 1;\n  }\n\n  return ws;\n}\n\nexport function resetPitchDetectorState(opts?: { seedMidi?: number }) {\n  // Optional: seed the detector with an expected MIDI so the very next frame\n  // can't \"accept\" a wildly wrong pitch immediately after a reset (common at\n  // note boundaries / attacks). When seeded, the spike-gate will hold until\n  // a large jump is confirmed for multiple frames.\n  state.lastStableMidi = typeof opts?.seedMidi === 'number' ? opts.seedMidi : null;\n  state.pendingJumpMidi = null;\n  state.pendingJumpCount = 0;\n}\n\n// Helpers\nfunction midiToFreq(midi: number): number {\n  return 440 * Math.pow(2, (midi - 69) / 12);\n}\n\nfunction freqToExactMidi(freq: number): number {\n  return 69 + 12 * Math.log2(freq / 440);\n}\n\nfunction clamp(v: number, lo: number, hi: number): number {\n  return Math.max(lo, Math.min(hi, v));\n}\n\nfunction dcRemoveAndApplyHann(\n  src: Float32Array,\n  dst: Float32Array,\n  hann: Float32Array,\n  mean: number\n) {\n  // DC removal + Hann window (helps autocorr stability)\n  for (let i = 0; i < src.length; i++) {\n    dst[i] = (src[i] - mean) * hann[i];\n  }\n}\n\n/**\n * Normalized autocorrelation for a given lag:\n *  r(lag) = sum(x[i]*x[i+lag]) / sqrt(sum(x[i]^2) * sum(x[i+lag]^2))\n * This keeps \"clarity\" more meaningful across levels and transitions.\n */\nfunction findBestLagNacf(\n  x: Float32Array,\n  prefixEnergy: Float64Array,\n  sampleRate: number,\n  minFreq: number,\n  maxFreq: number\n): { bestLag: number; clarity: number; corrAtLag: (lag: number) => number } {\n  const n = x.length;\n\n  const minLag = Math.floor(sampleRate / maxFreq);\n  const maxLag = Math.floor(sampleRate / minFreq);\n\n  // Precompute prefix energy for fast segment energy\n  // prefixEnergy length must be n+1\n  prefixEnergy[0] = 0;\n  for (let i = 0; i < n; i++) prefixEnergy[i + 1] = prefixEnergy[i] + x[i] * x[i];\n\n  const energy = (start: number, end: number) => prefixEnergy[end] - prefixEnergy[start];\n\n  const corrAtLag = (lag: number): number => {\n    const m = n - lag;\n    if (m <= 0) return 0;\n\n    let num = 0;\n    for (let i = 0; i < m; i++) {\n      num += x[i] * x[i + lag];\n    }\n\n    const e1 = energy(0, m);\n    const e2 = energy(lag, lag + m);\n    const den = Math.sqrt(e1 * e2);\n\n    if (den <= 1e-12) return 0;\n    return num / den; // in [-1..1]\n  };\n\n  let bestLag = -1;\n  let best = -1;\n\n  for (let lag = minLag; lag <= maxLag; lag++) {\n    const c = corrAtLag(lag);\n    if (c > best) {\n      best = c;\n      bestLag = lag;\n    }\n  }\n\n  return { bestLag, clarity: clamp(best, 0, 1), corrAtLag };\n}\n\nfunction parabolicInterpolatePeak(\n  lag: number,\n  corrAtLag: (lag: number) => number\n): number {\n  // refine lag using (lag-1, lag, lag+1)\n  const c0 = corrAtLag(lag - 1);\n  const c1 = corrAtLag(lag);\n  const c2 = corrAtLag(lag + 1);\n\n  const denom = (c0 - 2 * c1 + c2);\n  if (Math.abs(denom) < 1e-12) return lag;\n\n  const delta = 0.5 * (c0 - c2) / denom;\n  if (Math.abs(delta) > 1) return lag;\n\n  return lag + delta;\n}\n\nfunction applySpikeGate(exactMidi: number): number {\n  // If we don't have a stable midi yet, accept immediately.\n  // (Callers can seed lastStableMidi via resetPitchDetectorState({ seedMidi }) to avoid\n  // immediate acceptance of a wrong first frame at transitions.)\n  if (state.lastStableMidi == null) {\n    state.lastStableMidi = exactMidi;\n    state.pendingJumpMidi = null;\n    state.pendingJumpCount = 0;\n    return exactMidi;\n  }\n\n  const diffCents = (exactMidi - state.lastStableMidi) * 100;\n  const abs = Math.abs(diffCents);\n\n  // Small movement: accept and reset pending\n  if (abs < SPIKE_GATE_CENTS) {\n    state.lastStableMidi = exactMidi;\n    state.pendingJumpMidi = null;\n    state.pendingJumpCount = 0;\n    return exactMidi;\n  }\n\n  // Large jump: require confirmation\n  if (state.pendingJumpMidi == null) {\n    state.pendingJumpMidi = exactMidi;\n    state.pendingJumpCount = 1;\n    return state.lastStableMidi; // hold stable for now\n  }\n\n  // If new reading agrees with pending jump (within 30 cents), confirm\n  const agreeCents = Math.abs((exactMidi - state.pendingJumpMidi) * 100);\n  if (agreeCents <= 30) {\n    state.pendingJumpCount += 1;\n  } else {\n    // pending changed direction/target -> restart pending\n    state.pendingJumpMidi = exactMidi;\n    state.pendingJumpCount = 1;\n    return state.lastStableMidi;\n  }\n\n  if (state.pendingJumpCount >= SPIKE_GATE_CONFIRM_FRAMES) {\n    state.lastStableMidi = state.pendingJumpMidi;\n    state.pendingJumpMidi = null;\n    state.pendingJumpCount = 0;\n    return state.lastStableMidi;\n  }\n\n  return state.lastStableMidi;\n}\n\n/**\n * Detect pitch from an audio buffer.\n * - If targetHint exists: narrows search to \u00B13 semitones around target\n * - Never \"snaps\" to target: it just constrains the lag range\n * - Returns frequency + clarity\n */\n// Exported for A/B testing / future re-enable (avoids TS noUnusedLocals in builds).\nexport function detectPitchNacf(\n  buffer: Float32Array,\n  sampleRate: number,\n  targetHint?: TargetHint\n): PitchResult {\n  const n = buffer.length;\n  if (n === 0) return { frequency: null, clarity: 0 };\n\n  // Compute DC mean and RMS in one pass (no allocations).\n  let sum = 0;\n  let sumSq = 0;\n  for (let i = 0; i < n; i++) {\n    const v = buffer[i];\n    sum += v;\n    sumSq += v * v;\n  }\n  const mean = sum / n;\n  const rms = Math.sqrt(sumSq / n);\n  if (rms < RMS_THRESHOLD) {\n    // reset gating slowly? keep last stable to avoid flicker if you prefer:\n    // state.pendingJumpMidi = null; state.pendingJumpCount = 0;\n    return { frequency: null, clarity: 0 };\n  }\n\n  // Preprocess\n  const w = ensureWorkspace(n);\n  dcRemoveAndApplyHann(buffer, w.windowed, w.hann, mean);\n\n  // Choose search band\n  let minFreq = DEFAULT_MIN_FREQ;\n  let maxFreq = DEFAULT_MAX_FREQ;\n\n  if (targetHint) {\n    const targetFreq = midiToFreq(targetHint.targetMidi);\n    const ratio = Math.pow(2, TARGET_SEMITONE_SPAN / 12); // ~1.189\n    minFreq = Math.max(DEFAULT_MIN_FREQ, targetFreq / ratio);\n    maxFreq = Math.min(DEFAULT_MAX_FREQ, targetFreq * ratio);\n  }\n\n  // Find best lag by NACF\n  const { bestLag, clarity, corrAtLag } = findBestLagNacf(w.windowed, w.prefixEnergy, sampleRate, minFreq, maxFreq);\n\n  if (bestLag === -1 || clarity < MIN_CLARITY) {\n    return { frequency: null, clarity };\n  }\n\n  // Refine lag\n  let refinedLag = bestLag;\n  if (bestLag > 2) {\n    refinedLag = parabolicInterpolatePeak(bestLag, corrAtLag);\n  }\n\n  let frequency = sampleRate / refinedLag;\n\n  // Sanity clamp\n  if (frequency < DEFAULT_MIN_FREQ || frequency > DEFAULT_MAX_FREQ) {\n    return { frequency: null, clarity: 0 };\n  }\n\n  // Spike gate in MIDI domain (suppresses 1-frame jumps)\n  const exactMidi = freqToExactMidi(frequency);\n  // If we have a target hint but no stable state yet (e.g. after silence),\n  // anchor the gate to the target so we don't accept a random wrong pitch on\n  // the very first frame.\n  if (state.lastStableMidi == null && targetHint && typeof targetHint.targetMidi === 'number') {\n    state.lastStableMidi = targetHint.targetMidi;\n  }\n  const gatedMidi = applySpikeGate(exactMidi);\n  const gatedFreq = midiToFreq(gatedMidi);\n\n  return { frequency: gatedFreq, clarity };\n}\n\nfunction detectPitchPitchy(\n  buffer: Float32Array,\n  sampleRate: number,\n  _targetHint?: TargetHint\n): PitchResult {\n  const n = buffer.length;\n  if (n === 0) return { frequency: null, clarity: 0 };\n\n  // Keep our RMS gate to avoid nonsense output on near-silence.\n  let sumSq = 0;\n  for (let i = 0; i < n; i++) sumSq += buffer[i] * buffer[i];\n  const rms = Math.sqrt(sumSq / n);\n  if (rms < RMS_THRESHOLD) return { frequency: null, clarity: 0 };\n\n  const detector = getPitchyDetector(n);\n  const [pitch, c] = detector.findPitch(buffer, sampleRate);\n  const clarity = clamp(typeof c === 'number' ? c : 0, 0, 1);\n\n  let frequency =\n    typeof pitch === 'number' && Number.isFinite(pitch) && pitch > 0 ? pitch : null;\n\n  // Sanity clamp\n  if (frequency != null && (frequency < DEFAULT_MIN_FREQ || frequency > DEFAULT_MAX_FREQ)) {\n    frequency = null;\n  }\n\n  // NOTE: For \"raw pitchy\" evaluation we intentionally do NOT apply:\n  // - target-based rejection\n  // - spike gate / seeding\n  // Callers can still gate on MIN_CLARITY and RMS_THRESHOLD externally.\n  return { frequency, clarity };\n}\n\nexport function detectPitch(\n  buffer: Float32Array,\n  sampleRate: number,\n  targetHint?: TargetHint\n): PitchResult {\n\n  //const kind = getDetectorKind();\n  //return kind === 'pitchy'\n  //  ? detectPitchPitchy(buffer, sampleRate, targetHint)\n  //  : detectPitchNacf(buffer, sampleRate, targetHint);\n  return detectPitchPitchy(buffer, sampleRate, targetHint);\n}\n\n/**\n * Convert frequency to note information (name, MIDI, cents offset)\n */\nexport function frequencyToNoteInfo(freq: number): NoteInfo | null {\n  if (freq <= 0) return null;\n\n  const exactMidi = 69 + 12 * Math.log2(freq / 440);\n  const nearestMidi = Math.round(exactMidi);\n  const centsOff = Math.round((exactMidi - nearestMidi) * 100);\n\n  const noteIndex = ((nearestMidi % 12) + 12) % 12;\n  const octave = Math.floor(nearestMidi / 12) - 1;\n  const noteName = NOTE_NAMES[noteIndex] + octave;\n\n  return {\n    noteName,\n    midi: nearestMidi,\n    exactMidi,\n    centsOff,\n  };\n}\n", "/// <reference path=\"./audioworklet-globals.d.ts\" />\r\nimport { detectPitch } from '../pitchDetection'\r\n\r\ntype PitchMessage =\r\n  | { type: 'pitch'; frequency: number | null; clarity: number; audioTimeSec: number; halfWindowSec: number; detectMs?: number }\r\n  | { type: 'ready' }\r\n\r\ntype ControlMessage =\r\n  | { type: 'config'; windowSize: number; analysisIntervalMs: number }\r\n\r\nclass PitchDetectorProcessor extends AudioWorkletProcessor {\r\n  private windowSize = 4096\r\n  private analysisIntervalMs = 50\r\n\r\n  private ring = new Float32Array(this.windowSize)\r\n  private window = new Float32Array(this.windowSize)\r\n  private writeIdx = 0\r\n  private filled = false\r\n\r\n  private hopSamples = Math.max(1, Math.round(sampleRate * (this.analysisIntervalMs / 1000)))\r\n  private samplesSinceLast = 0\r\n\r\n  constructor(options?: AudioWorkletNodeOptions) {\r\n    super()\r\n\r\n    const po = options?.processorOptions as any\r\n    if (po && typeof po.windowSize === 'number') this.windowSize = po.windowSize\r\n    if (po && typeof po.analysisIntervalMs === 'number') this.analysisIntervalMs = po.analysisIntervalMs\r\n\r\n    this.rebuildBuffers()\r\n\r\n    this.port.onmessage = (ev: MessageEvent<ControlMessage>) => {\r\n      const msg = ev.data\r\n      if (!msg || typeof msg !== 'object') return\r\n\r\n      if (msg.type === 'config') {\r\n        if (typeof msg.windowSize === 'number' && msg.windowSize > 0) this.windowSize = msg.windowSize\r\n        if (typeof msg.analysisIntervalMs === 'number' && msg.analysisIntervalMs > 0) this.analysisIntervalMs = msg.analysisIntervalMs\r\n        this.rebuildBuffers()\r\n      }\r\n    }\r\n\r\n    const ready: PitchMessage = { type: 'ready' }\r\n    this.port.postMessage(ready)\r\n  }\r\n\r\n  private rebuildBuffers() {\r\n    this.ring = new Float32Array(this.windowSize)\r\n    this.window = new Float32Array(this.windowSize)\r\n    this.writeIdx = 0\r\n    this.filled = false\r\n    this.samplesSinceLast = 0\r\n    this.hopSamples = Math.max(1, Math.round(sampleRate * (this.analysisIntervalMs / 1000)))\r\n  }\r\n\r\n  private pushSamples(input: Float32Array) {\r\n    // Fill ring buffer with incoming samples\r\n    for (let i = 0; i < input.length; i++) {\r\n      this.ring[this.writeIdx] = input[i]\r\n      this.writeIdx++\r\n      if (this.writeIdx >= this.windowSize) {\r\n        this.writeIdx = 0\r\n        this.filled = true\r\n      }\r\n    }\r\n  }\r\n\r\n  private snapshotWindow() {\r\n    // Oldest sample is at writeIdx (next write position)\r\n    const n = this.windowSize\r\n    const w = this.writeIdx\r\n    const firstLen = n - w\r\n    this.window.set(this.ring.subarray(w, n), 0)\r\n    this.window.set(this.ring.subarray(0, w), firstLen)\r\n  }\r\n\r\n  process(inputs: Float32Array[][], outputs: Float32Array[][]) {\r\n    const input = inputs[0]?.[0]\r\n    const output = outputs[0]?.[0]\r\n    if (!input) return true\r\n\r\n    // Keep graph alive by passing input through if an output exists.\r\n    if (output) output.set(input)\r\n\r\n    this.pushSamples(input)\r\n    this.samplesSinceLast += input.length\r\n\r\n    if (this.filled && this.samplesSinceLast >= this.hopSamples) {\r\n      this.samplesSinceLast = 0\r\n\r\n      this.snapshotWindow()\r\n\r\n      const t0 = (globalThis as any).performance?.now?.()\r\n      const r = detectPitch(this.window, sampleRate)\r\n      const t1 = (globalThis as any).performance?.now?.()\r\n\r\n      // currentTime is block start; include block duration to approximate end time.\r\n      const blockEndTime = currentTime + input.length / sampleRate\r\n      const halfWindowSec = (this.windowSize / sampleRate) / 2\r\n\r\n      const msg: PitchMessage = {\r\n        type: 'pitch',\r\n        frequency: r.frequency,\r\n        clarity: r.clarity,\r\n        audioTimeSec: blockEndTime,\r\n        halfWindowSec,\r\n        detectMs: typeof t0 === 'number' && typeof t1 === 'number' ? (t1 - t0) : undefined\r\n      }\r\n      this.port.postMessage(msg)\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\nregisterProcessor('pitch-detector', PitchDetectorProcessor)\r\n\r\n\r\n"],
  "mappings": "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",
  "names": ["FFT", "FFT", "sampleRate", "sampleRate"]
}
